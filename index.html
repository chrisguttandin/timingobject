<!DOCTYPE html>
<html>
  <head>
    <title>Timing Object</title>
    <meta charset="utf-8">
    <script src="http://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
    <script class="remove">
      var respecConfig = {
          specStatus: "ED",
          edDraftURI: "http://webtiming.github.io/timingobject",
          shortName:  "timing-object",
          editors: [
            {
              name:       "François Daoust",
              company:    "W3C",
              companyURL: "http://www.w3.org",
              mailto:     "fd@w3.org"
            },
            {
              name:       "Ingar M. Arntzen",
              company:    "Motion Corporation",
              companyURL: "http://motioncorporation.com/",
              mailto: "ingar.arntzen@motioncorporation.com"
            }
          ],
          authors: [
            {
              name:       "Njål T. Borch",
              company:    "Motion Corporation",
              companyURL: "http://motioncorporation.com/",
              mailto: "njaal.borch@motioncorporation.com"
            }
          ],
          wg:           "Multi-Device Timing Community Group",
          wgURI:        "http://www.w3.org/community/webtiming/",
          wgPublicList: "public-webtiming",

          localBiblio:  {
            "MSV": {
              title:    "The Media State Vector: A unifying concept for multi-device media navigation",
              href:     "http://dl.acm.org/citation.cfm?doid=2457413.2457427",
              authors:  [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "Christopher P. Needham"
              ]
            }
        }
      };
    </script>
    <style type="text/css">
      table { border-collapse: collapse; border-style: hidden hidden none hidden; }
      table thead, table tbody { border-bottom: solid; }
      table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    </style>
  </head>
  <body>



  <!-- ABSTRACT -->

    <section id="abstract">
      <p>
        This specification defines a timing object and an associated API. The timing object is a local object that may be used by Web clients to ensure precisely timed execution. If multiple time-sensitive components take direction from the same timing object, their behaviour will be precisely coordinated in time. Crucially, this is also the case in distributed settings. A central motivation for the timing object is that it may be connected to an online timing resource. This way, the local timing object is a gateway to precisely timed operations, both in single-device as well as multi-device scenarios.
      </p>
  

      <p class="note">
        This timing object is not to be confused with concepts proposed by 
        <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/NavigationTiming/Overview.html">Navigation Timing</a>, an initiative targeting precise measurement of time consumption in Web browsers.
      </p>

    </section>






    <section id="sotd">
      <p>
        The specification is intended for discussion within the Multi-Device Timing Community Group. Its content does not yet represent the consensus of the Community Group.
      </p>
    </section>
    




    <!-- INTRODUCTION -->


    <section class="informative">
      <h2>Introduction</h2>
      
      <p>
        Timing mechanisms allow operations to be executed at the correct time. The Web already has several mechanisms supporting timed operations, including <i>setTimeout</i>, <i>setInterval</i>, as well as controllers for media frameworks and animations. Unfortunately, these mechanisms are limited in scope, as they only apply to timed operations within a single web page. In contrast, a multi-device timing mechanism allows precisely timed operations across Web pages hosted by different devices. The <a href="https://www.w3.org/community/webtiming/">W3C Multi-device Timing Community Group</a> has been formed with the goal of extending the Web with native support for precisely timed operation in the multi-device scenario, as well as providing a unifying model to which all frameworks for timed operation may integrate. The timing object is the central concept in this initiative.
      </p>

      <p>
        Synchronized playback of multi-device linear media is an important use-case for multi-device timing. However, multi-device timing has wide utility for a variety of timing related challenges, including distributed media control and remote control, distributed synchronization, distributed time-shifting, distibuted time-ordering and distributed recording (time-stamping). This way, multi-device timing has applicability in many application domains, including TV and radio (broadcast and IP-based), secondary device applications, online education, VodServices, scientific visualization, music etc.  
      </p>

 
      




      <section>
        <h3>Linear Composition</h3>
        <p>
          Multi-device timing has particular importance for multi-device, linear media, as it is key to distributed, time-sensitive playback. Here we express the motivation of the timing object specifically in the context of linear media. So, an important purpose of introducing the timing object into HTML is to enable <i>linear composition</i> in both single-device and multi-device linear media. 
        </p>

        <p>
          Linear composition is simply the idea that complex linear media could be built from simpler, independent linear components. This way, the classical benefits of composition as a design principle, i.e. flexibility, reusability, extensibility and mashup-ability, would fully apply to linear media. For example, in the single-device scenario, imagine a linear presentation made from HTML5 video, some timed meta-information, a SMIL component, a WebAnimation, a map with timed georeferenced data, and a timed Twitter widget. Or, in the multi-device scenario, imagine the same components distributed or duplicated across multiple devices. In both cases linear composition requires interoperability of heterogeneous linear components, through precisely coordinated, timed playback. Currently though there is weak support for linear composition, and a main reason for this is that timing control mechanisms are custom and internal to each framework. This central purpose of the timing object is thus to simplify interoperability by providing a common basis for timing control in linear media.
        </p>

        <p>
         For a more extensive introduction to linear composition, please consult paper "Multi-device Linear Composition on the Web; Enabling Multi-device Linear Media with timing object and Shared Motion" by Arntzen et.al. This paper is currently submitted for publication, and will be made available on the <a href="https://www.w3.org/community/webtiming/">W3C Multi-device Timing Community Group</a> when it is published.
        </p>
      </section>

      <section>
        <h3>Design Goals and Architecture</h3>

        <p>
          The design of the timing object has two main goals:
        </p>
        <ol>
          <li>
            provide a unifying API for timed operation, as a basis for interoperability between timed components. In particular, support integration with existing timed frameworks such as HTMLMediaElements, HTMLTrackElement, WebAnimation, WebAudio and SMIL. The API must support highly precise timing, and be expressive enough to support control primitives appropriate for a wide range of media types and applications.
          </li>
          <li> 
            encapsulate complexity of distributed time synchronization, thereby allowing integrating frameworks to be included in precisely timed multi-device operation. In particular, by providing the same API for local and online timing resources, timed components may be used in single-device and multi-device scenarios, without modification. 
          </li>
        </ol>


        <p>
          The figure below illustrates these functions, as well as the underlying client-server architecture. Three devices each have a single timing object, which are then individually connected to a single, shared online timing resource. Internally on each device, the timing object will act as the director for independent, time-sensitive GUI components. This way, a video will aim to present videoframes in accordance with the timing resource. Similarly, a time-sensitive Twitter widget might replay time-stamped Tweets. If the timing object pauses, the connected components are notified and react accordingly. Crucially, note how the different components can go about their business in complete isolation. There is no need for components to communicate, except indirectly through the timing object. This loose coupling is the key to linear compsability.
        </p>
        <p>
          Furthermore, when timing objects are connected to an online timing resource, they will act as local representatives. For example, if a connected timing object is requested to pause, the request will simply be forwarded to the online timing object. As the online object pauses, notifications will be multicast to all connected clients. Finally, timing object will update their internal state and notify connected UI components. For online timing objects, clients can expect update latency of about one round trip time (TCP), whereas local timing resources should have no update latency. Apart from this, online and local timing resources should be hard to distinguish. Note also that the argument made for the independence of time-sensitive components in the single-device scenario now applies to the multi-device scenario as well. 
        </p>

        <figure>
          <img src="overview.png" width="400" alt="The image illustrates the concept of an online timing resource how it used to synchronize HTTPTimingObjects across three different Web clients." />
          <figcaption>timing objects at three devices connected to a single, shared online timing resource.</figcaption>
        </figure>
   
        <p class="note">
          The protocol used to connect, synchronize and interact with online timing resources will be defined in a separate specification.
        </p>
        <p class="note">
          Similarly, the integration of the timing object with other frameworks for timed operation, such as HTML5 Media Elements, HTML5 Track Elements, Web Animation, SMIL, and Web Audio [[HTML5]] will be covered separately.
        </p>
      </section>

      <section>
        <h3>Timing object</h3>
        <p>
          The timing object is conceptually a very simple object, essentially an advanced stop watch. If started, its value changes predictably in time, until at some point later, it is paused, or perhaps reset. It may be queried for its value at any time. For example, it should take exactly 2.0 seconds for the value to advance from 3.0 to 5.0 when the velocity is 1.0. Such deterministic behavior is required for reliable distributed synchronization. In terms of implementation, the timing object is a fairly thin wrapping around the system clock (integration with online timing resources adds a bit of complexity). Since it is based on the system clock, the timing object supports the same resolution and predictability as the system clock. This makes the timing object a sound basis for precise timing.
        </p>
        <p>
          Importantly, the timing object is more expressive than the traditional stop watch. It supports any velocity or acceleration, and may jump to any position on the timeline. In fact, the timing object essentially implements linear motion along a unidimensional axis. An elegant implementation is provided by the concept of Media State Vectors [[MSV]], based on the classical equations of linear motion under constant acceleration. The timing object adopts this model. At any point in time, position, velocity or acceleration may be requested to change. Querying the timing object reveals not only its current value (position) but also its velocity and acceleration at that moment. This detailed information is again helpful in precise synchronization, and the expressiveness of the underlying mathematical model implies that a wide variety of control primitives may be supported. In particular, discrete jumps on the timeline may be used to control a slide show, whereas velocity corresponds to <code>playbackRate</code> for the control of continuous media. Acceleration is required by certain animation frameworks.
       </p>
       <p>
          We are not the first to define timing controls for linear media. Similar constructs have been explored in both academia and industry from the 70'ies and onwards. Indeed, any framework for linear media would maintain similar constructs internally. Instead, the novelty is to represent timing as an explicit resource on the Web, independent of framework, thereby creating a basis for interoperability. Also, integration with server-hosted, online timing resources is a novelty.
        </p>

        <figure>
          <img src="stopwatch_digital.jpg" width="80" alt="The timing object is essentially and advanced stop watch." />
          <figcaption>The timing object is essentially an advanced stop watch.</figcaption>
        </figure>
          <figure>
          <img src="timeline.png" width="400" alt="The timing object is essentially and advanced stop watch." />
          <figcaption>The timing object visualized as a cursor moving along a timeline.</figcaption>
        </figure>
      </section>

      <section>
        <h3>Programming with timing objects</h3>

        <p>
          Timing objects are resources used by your application, and you may define as many as you like. What purposes they serve in the application is up to the programmer. If the application needs a shared, multi-device clock, just start a timing object and make sure you never stop it. If you want the clock value to represent milliseconds, just set the velocity to 1000 (advances the timing object with 1000 milliseconds per second). If the timing object represents media offset, just specify the playback position, the velocity, and perhaps a media duration. For video you might measure offset in seconds or frames and set the velocity accordingly. Or, for musical applications it may be practical to let the timing object represent beats per second. Note also that the timing object may represent time-changes with any kind of variable. For instance, if you have data that is organized according to, say height above sea level, you may want to animate how this data changes as you move vertically. In this case the timing object might represent meters or feet above sea level, and positive and negative velocities would allow you to move both upwards and downwards.
        </p>
        <p>
          In general, the timing object is particularly useful when you have a variable that needs to change predictably in time. You may of course achieve this simply by overwriting a value repeatedly in time (this is essentially the approach of the current <code>HTMLMediaElement</code> interface), but the timing object provides an improvement on this approach, particularly with respect to precise synchronization.
        </p>
      </section>    
    </section>















    <!-- USE CASES -->


    <section class="informative">
      <h2>Use cases and requirements</h2>
      <p>
        Precise timing has wide applicabilty in both single-device and multi-device applications. Here we identify some common use cases.
      </p>


      <section>
      <h3> Social Viewing and Media Control</h3>
      <p>
        Allow people to enjoy the same content at the same time. Alice and Bob would like to watch the next episode together, even if Alice is on a train and Bob stays at home. If Alice pauses the video while briefly speaking with the conductor, Bob's video pauses too. Alice and Bob may always trust the other to see the exact same thing, making it very easy for them to maintain a conversation, for instance by using a chat service or the phone. It would also be possible for Alice and Bob to split temporarily. Alice would see Bob moving along the progress line without her, and Bob would see Alice staying behind. When Alice is ready to resume viewing a bit later, she may continue on her own, play doublespeed or skip to catch up with Bob, or convice Bob to wait for her or jump back to see the segment again with her.      
      </p>
      <p>
        This use case is based on <a href="http://www.w3.org/2011/webtv/wiki/New_Ideas">UC2-3 Identical Media Stream Synchronization</a>, a use case defined by the <a href="http://www.w3.org/2011/webtv/">W3C Web and TV Interest Group</a>
      </p>
      <p>
        This use case requires the management and sharing of multiple timing objects, at least one for Alice and one for Bob. Precision requirements for video synchronization are quite coarse as the use case is described. However, Alice and Bob might also choose to use this application in circumstances where they are sitting next to eachother, or they might hook their devices on to projectors in order to show a movie to a larger audience. Sub-framerate precision is required in order to avoid echo from device speakers. 
      </p>
      </section>

      <section>
      <h3> Broadcasting - Time-consistent, Live Web Productions </h3>
      <p>
        The BBC provides live coverage of popular sport events such as the FIFA World Cup. Modern Web presentations of this kind tend to include many independent media streams. For example, there might be multiple video streams for different camera angles, visualizations of players on the field, player statistics, and there might be commentary from studio as well as viewers. Earlier, Bob was annoyed that user comments could sometimes ruin the experience by shouting "GOAL!" 20 seconds before the goal appeared in the video stream. However, after BBC started timeshifting live Web content to match distribution latency in their video backend, this problem seems to be a thing of the past.
      </p>
      <p>
        This requires figuring out the estimated latency of the slowest distribution mechanism, and then to define a timing resource from which all parts of a presentation takes direction. In effect, early spoilers will be delayed (buffered) by the Web browsers and applied to UI components at the correct moment in time.
      </p>
      </section>

      <section>
      <h3> Broadcasting - Time-shifted, Live Web productions </h3>
      <p>
        A commercial media provider offers live Web content supplementing live broadcast of F1 races. Sometimes, as F1 races are held in different time zones, the provider will re-broadcast nightly races in the morning. As a keen F1 enthusiast, Alice is discontent that the Web content can not be time-shifted along with the re-broadcast of the race. So is Bob, the media provider's head of marketing, as he would like to sell time sensitive, Web-based ads for F1 races, and have the ads be presented correctly for both live and time-shifted broadcasts, as well as later on demand viewers.
      </p>
      <p>
        This requires timestamping of live Web production so that is may be time-shifted correctly and aligned with a time-shifted broadcast.
      </p>
      </section>

      <section>
      <h3> Broadcasting - Timed, Web-based Secondary Device </h3>
      <p>
        Alice opens the BBC Sport Web page on her iPad during the olympic games. The backend service consults Alice's profile and learns that she is already watching figure skating from the iPlayer on her laptop computer. As a result, the BBC Sports Web page is personalized with an offer to load BBC's Web-based extra material for figure skating. Alice accepts, and the iPad goes on to present stats, images, infographics, commentary and alternative camera angles, all precisely timed with the iPlayer. Alice notices that other viewers have already highlighted a Chinese athlete performing a bit earlier. She clicks to see it, and both the iPlayer (on the laptop) and the timed Web presentation (on the iPad) immediately skip back. After having seen the athlete's performance, now with added commentary provided by excited viewers, Alice contributes by giving it a thumbs up, and then clicks the back-to-live button. Both the laptop and the iPad snap back to presenting the live action.
      </p>
      <p>
        This use case is based on <a href="http://www.w3.org/2011/webtv/wiki/New_Ideas">UC2-4 Related Media Stream Synchronization</a>, a use case defined by the <a href="http://www.w3.org/2011/webtv/">W3C Web and TV Interest Group</a>
      </p>
      <p>
        This use case requires managing personal timing resources for individual viewers, as well as a common timing resource representing the live clock. Both iPlayer and Web-based secondary device offerings must take direction from online timing resources, and allow dynamic switching of timing objects based on user input. Presenting alternative camera angles as part of secondary device offerings requires precise synchronization.   
      </p>
      </section>


      <section>
      <h3> Online Education - Timed, Multi-device Web Presentations </h3>
      <p>
        Alice teaches an online course for international students from across the globe. Every week she goes through a new Web-based slide set. Just before the session, she makes two links available for her students on the class Web page, links for the primary and the secondary view of the presentation. When the time is there she connects on an audio link and requests the first slide to be presented. Slides are presented on her view and on all the views of her connected students, at exactly the same time. This way, Alice can be sure that what she says on the audio link is always backed up with the correct illustrations. In effect, Alice remotely controls the Web browsers of all her students. Alice also has included a video in one of the slides. She plays the video for all the students on the primary view, while presenting some related bullet points on the secondary view. Alice pauses the video at a certain point in order to highlight an important aspect. Beforehand she has prepared some bookmarks in the video, allowing her to effectively skip to the interesting parts. At some point one of the students has a question related to the movie. Alice temporarily gives the student access to control the video, and the student rewinds it to explain the origin of his question. Afterwards, Alice withdraws the controls from the student and continues. The entire event is recorded and timestamped, allowing students that missed the class to replay the audio with and the slide presentation precisely as it was given. This review also provides synchronized presentations of timed comments provided by students as well as text-based search capabilities allowing efficient navigation within the presentation.         
      </p>
      <p>
        Multi-device slide show navigation requires a single shared timing resource, where position represents slide number. Videos require additional timing resources. Finally, timestamping of audio, slide navigation, video navigation, students commentary etc., require an addition timing resource as shared clock. Later individual replay might also require new timing resources.  
      </p>
      </section>


      <section>
      <h3> Multi-Screen Data Visualization </h3>
      <p>
        Bob is heading a research project responsible for collecting and presenting a variety of data series related to climate changes in the Arctic. A Web-based approach to visualization makes for a very dynamic and extensible visualization system. Multiple screens may be used to present and align very different timed visualizations, making it easier to detect temporal patterns and possible correlations. The different visualizations may be navigated in unison. For instance, Bob may slow down the presentation speed for the heavy melting days to co-present this with measurements of salinity levels in the ocean water. Bob may also search his data to find the day with the highest temperature. By clicking on the result, all screens immediately display the relevant data for that day. Alice is recognized as an international expert in this area. Bob shares the link with Alice in an email, they may co-view the presentation even though they are stationed in different continents, and Alice may explore the visualization herself before giving her opinion of Bob's finding. 
      </p>
      <p>
        A shared timing resource is required to support playback of timed data streams on multiple screens. The utility is not limited to Web-based visualization. For instance, native visualization frameworks (e.g. 3D) may also interact with multi-device timing resources, thus enabling very different visualization systems to cooperate in presenting a common data model. 
      </p>
      </section>



      <section>
      <h3> Seamless Workflows </h3>
      <p>
        Bob is watching a Netflix show using Chromecast on the TV when Alice interrupts and demands access to the living room big screen for herself and her friends. Bob reluctantly agrees to finish the show in his bedroom. Though, before he gets up he opens Netflix on his iPad. Netflix, well aware that Bob is already actively watching something, defaults to presenting the exact same thing, in perfect synchrony with the TV. Ensured that the transition was smooth, Bob leaves for his bedroom while staring at his iPad.
      </p>
      <p>
        The use case requires online timing resources and content resources to be tied to login information. So, when an already logged in user enters a VoD service with a second device, the default action could be to resolve which show is already playing and what timing resource is being used, and then to set up the new view with the exact same resources. 
      </p>
      </section>


      <section>
      <h3> Alternative Soundtracks </h3>
      <p>
        Alice's Portuguese mother has a hearing deficiency, so as the two of them sit down to watch a movie together, Alice hooks her smart phone up with the Portuguese audio track and lets her mother adjust the sound volume. Any issues with lip-sync should be due to the dubbing, not the audio synchronization.
      </p>
      <p>
        This use case is based on <a href="http://www.w3.org/2011/webtv/wiki/New_Ideas">UC2-6 Clean Audio</a>, a use case defined by the <a href="http://www.w3.org/2011/webtv/">W3C Web and TV Interest Group</a>
      </p>
      <p>
        This requires lip-synch precision between video and audio. 
      </p>
      </section>


      <section>
      <h3> Timing Interoperability between Independent Providers </h3>
      <p>
        Bob watches soccer. Unfortunately, the clueless commentator is constantly pissing him off as he clearly favours the other team. Bob turns to a dedicated Web radio channel for an alternative commentary. The new commentator is better, but he is out of sync. Bob chooses the <i>SyncWith</i> option in the radio channel Web page and selects his TV provider. After confirming his credentials, the radio channel Web page is able to connect to the same timing resource used by the TV provider, and the Web radio is immediately in sync with his TV.
      </p>
      <p>
        This use case requires media providers to give access to timing resources associated with a given user, also when that user is requesting access from an external service. Synchronization of audio and video requires lip-synch precision.
      </p>
      </section>
 

      <section>
      <h3> Linear Content Adaptation </h3>
      <p>
        Bob is watching cricket, but he and Alice soon need to get in the car to start the long drive to visit Bob's parents. He would like to keep following the cricket game on his smart phone, but does not have the bandwidth nor the money to enjoy HD content. Instead, Bob selects the timed HTML option. The audio goes on undisturbed, but the HD video is immediately terminated and replaced with a light-weight, timed animation of the cricket field. Alice is behind the wheels, and Bob may continue to enjoy the cricket match through audio and full support from all the HTML-based extra information. 
      </p>
      <p>
        Shared timing resources allow smooth and dynamic switching from HD to timed-based HTML.   
      </p>
      </section>

      <section>
      <h3> Distributed Recording and Replayability </h3>
      <p>
        use case ...
      </p>
      <p>
        requirements ...
      </p>
      </section>

      <section>
      <h3> Distributed Music Production and Playback  </h3>
      <p>
        use case ...
      </p>
      <p>
        requirements ...
      </p>
      </section>

      <section>
      <h3> Time sensitive Interactive Commercials </h3>
      <p>
        use case ...
      </p>
      <p>
        requirements ...
      </p>
      </section>
    </section>










    <!-- CONFORMANCE -->

    <section id="conformance">
      <p>
        Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and terminate these steps") are to be interpreted with the meaning of the key word ("must", "should", "may", etc.) used in introducing the algorithm.
      </p>

      <p>
        Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant).
      </p>

      <p>
        This specification defines conformance criteria that apply to a single product: the <dfn>user agent</dfn> that implements the interfaces that it contains.
      </p>
    </section>











    <!-- TERMINOLOGY -->

    <section>
      <h2>Terminology</h2>

      <p>
        The terms <dfn><a href="http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event handler</a></dfn> and <dfn><a href="http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event handler event type</a></dfn> are defined in [[!HTML5]].
      </p>

      <p>
        The <dfn><code><a href="http://www.w3.org/TR/dom/#event">Event</a></code></dfn> interface represents an event as defined in [[!DOM]].
      </p>

      <p>
        The <code><a href="http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code> interface represents a callback used for <a title="event handler">event handlers</a> as defined in [[!HTML5]].
      </p>


      <p>
        An <dfn>online timing resource</dfn> is an object identified by a URL and hosted by a timing service. An <a>online timing resource</a> may be used to represent various application-level timing concepts, such as clocks, timeouts, stop-watches or media controllers. Timing resources are created and used by Web applications in order to support precisely timed operation in multi-device applications.
      </p>

      <p>
        This document provides interface definitions using the [[!WEBIDL]] standard.
      </p>
    </section>











    <!-- EXAMPLES -->



    <section class="informative">
      <h2>Examples</h2>


      <section>
      <h3>Query</h3>
      <p> Read the current value of the timing object. </p>
      <pre class="example highlight">
      var to; // timing object
      var elem; // DOM Element
      var value = to.query();
      elem.innerHTML = "pos:" + value.pos + " vel:" + value.vel + " acc:" + value.acc; 
      </pre>
      </section>

      <section>
      <h3>Update</h3>
      <p>Use play and pause buttons to control the timing object.</p>
      <pre class="example highlight">
      var to; // timing object
      var playbutton;
      var pausebutton;
      playbutton.onclick = function (e) {to.update({vel:1.0})}; // set velocity 1
      pausebutton.onclick = function (e) {to.update({vel:0.0})}; // set velocity 0
      </pre>
      </section>

      <section>
      <h3>Polling</h3>
      <p>By querying the timing object repeatedly we can refresh time sensitive UI and demonstrate that the value of the timing object is changing predictably in time.</p>
      <pre class="example highlight">
      var to; // timing object
      var elem; // DOM Element
      setInterval(function () {
        elem.innerHTML = to.query().pos.toFixed(2);
      }, 100);
      </pre>

      <p>Alternatively, use the built in <i>timeupdate</i> event (fixed frequency).</p>
      <pre class="example highlight">
      var to; // timing object
      var elem; // DOM Element
      var to.on("timeupdate", function (r) {
        elem.innerHTML = to.query().pos.toFixed(2);
      });
      </pre>
      </section>

      <section>
      <h3>Update Event</h3>
      <p>Update operations cause abrupt changes to the timing object. Register a handler to be notified.</p>
      <pre class="example highlight">
      var to; // timing object
      var elem; // DOM Element
      to.on("update", function (e) {
        var value = to.query();
        if (value.vel === 0.0 &amp;&amp; value.acc === 0.0) {
          elem.innerHTML = "I'm not moving!";
        } else {
          elem.innerHTML = "I'm moving!";
        }
      });
      </pre>
      </section>

    </section>









    <!-- TIMING OBJECT -->



    <section>
      <h2>Timing Object</h2>

      <p>
        A <dfn>timing object</dfn> is conceptualized as a point moving along an infinite axis. The value of the timing object is essentially the position, velocity and acceleration of the point, at a specific moment in time. So, essentially, the timing object is a representation of linear motion in real time. The timing object uses a <a>media state vector</a> to represent the initial conditions of the current motion. This is known as the internal <dfn>vector</dfn> of the timing object. This <a>vector</a> is used by the <dfn>query</dfn> operation to calculate fresh <a>media state vector</a> snapshots, based on timestamps from the system clock. The <dfn>update</dfn> operation allows the timing object to be updated, by modifying the internal <a>vector</a>. The timing object supports any motion that can be expressed in terms of a <a>media state vector</a>. This way, the timing object is expressive enough to implement clocks, stop-watches and a variety of media controllers (at least the temporal aspects of media control). A <dfn>range</dfn> may be specified for the position of the timing object.
      </p>

      <p><a title="timing object">Timing objects</a> implement the following interface:</p>

      <dl title="interface TimingObject : EventTarget" class="idl">

      <!-- Constructor -->

        <dt>Constructor()</dt>
        <dd>
          <p>
            When the constructor is invoked, the user agent must <a>create a new timing object</a>.
          </p>
          <p class="issue">
            It is left as an open issue whether programmers instantiate timing objects themselves, or if the design should introduce a factory/manager object responsible for creating and managing timing objects.
          </p>
        </dd>


        <!-- Attributes -->

        <dt>readonly attribute DOMString src</dt>
        <dd>
          <p>
            Returns the URL identifying the timing resource to which the timing object is connected. For example, a timing object connected to an <a>online timing resource</a> identifies as <i>msv://timinghost/timingResourceID</i>. A local timing object may indentify as <i>msv:///timingResourceID</i>.
          </p>
          <p class="issue">
            It is left as an open issue whether the source attribute of timing objects may be set or reset, or if instead new timing objects should be generated.
          </p>
        </dd>

        <dt>readonly attribute DOMString readyState</dt>
        <dd>
          <p>"connecting", "open", "closed"</p>
        </dd>


        <dt>readonly attribute MediaStateVector vector </dt>
        <dd>The internal vector of the timing object</dd>
        <dt>readonly attribute MediaStateVector previousVector </dt>
        <dd>The vector that was replaced by the current internal vector. This may be helpful for computing the nature of the last change, after the fact.</dd>



        <dt>readonly attribute Interval range</dt>
        <dd>Defines range restritions for position of the timing object.</dd>

        <!-- Events -->

        <dt>attribute EventHandler onreadystatechange</dt>
        <dd>Event handler, of type <a>readystatechange</a>.</dd>

        <dt>attribute EventHandler onchange</dt>
        <dd>Event handler, of type <a>change</a>.</dd>

        <dt>attribute EventHandler ontimeupdate</dt>
        <dd>Event handler, of type <a>timeupdate</a>.</dd>

        <!-- Methods -->

        <dt>MediaStateVector query ()</dt>
        <dd>When invoked, the user agent must compute a snapshot from the internal <a>vector</a> and the current local time and return the result. See <a>process query</a> for details.</dd>

        <dt>void update ()</dt>
        <dd>
          When called, the user agent must update the internal <code>vector</code> if the timing object, based on the given <code>newVector</code>. The basic action is <code>vector=newVector</code> and set the timestamp correctly, i,e,. a fresh timestamp from the system clock representing the exact processing time of the update operation. However, the update operation also supports properties of <code>newVector</code> to be <code>undefined</code> or <code>null</code>. This provides a simple mechanism for tying movements together. The idea is to allow one aspect of the movement to be updated while preserving the others. For instance, <code>{position:null, velocity:value, acceleration:null}</code> means <i>update velocity while preserving current position and acceleration</i>. See <a>process update</a> for details.

          <dl class="parameters">
            <dt>optional MediaStateVector newVector</dt>
            <dd>The new vector</dd>
            <dt>optional Object options</dt>
            <dd>@@</dd>
          </dl>
        </dd>

        <dt>boolean isMoving ()</dt>
        <dd>Shorthand utility method. Returns False is both velocity and acceleration are equal to 0.0, else True.</dd>

        <dt>attribute readonly double currentPosition</dt>
          <dd>
            Shorthand accessor for current position, equivalent to <code>query().position</code>
          </dd>
        <dt>attribute readonly double currentVelocity</dt>
        <dd>Shorthand accessor for current velocity, equivalent to <code>query().velocity</code></dd>
        <dt>attribute readonly double currentAcceleration</dt>
        <dd>Shorthand accessor for current acceleration, equivalent to <code>query().acceleration</code></dd>


  
      </dl>

      <section>
        <h3>Events</h3>

        <p>The following events fire on timing objects:</p>

        <table>
          <thead>
            <tr>
              <th>Event name</th>
              <th>Interface</th>
              <th>Fired</th>
            </tr>
          </thead>
          <tbody>
 
            <tr>
              <td><dfn><code>change</code></dfn></td>
              <td><a><code>Event</code></a></td>
              <td>The internal <a>vector</a> is changed. Fired after the <code>update()</code> method has returned, or when an update is received from the <a>online timing resource</a>.</td>
            </tr>
            <tr>
              <td><dfn><code>readystatechange</code></dfn></td>
              <td><a><code>Event</code></a></td>
              <td>The <code>readyState</code> attribute changed.<br/></td>
            </tr>
            <tr>
              <td><dfn><code>timeupdate</code></dfn></td>
              <td><a><code>Event</code></a></td>
              <td>Fires peridically with fixed frequency 5Hz, except when timing object is paused. This is intended as a shorthand alternative for setting up a polling-loop with setInterval, or as an emulation of the pulse-based timing model that programmers are currently used to.</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>







    <!-- MediaStateVector -->



    <section>
      <h2>Media State Vector</h2>

      <p>
        A <dfn>media state vector</dfn> represents the classical four-tuple <code>(p,v,a,t)</code> associated with the mathematical description of linear motion under constant acceleration. The elements of this four tuple represent <code>(position, velocity, acceleration, time)</code>. The <a>timing object</a> uses the <a>media state vector</a> for multiple purposes. Internally, the <a>media state vector</a> represents the initial conditions of the current movement. This is known as the <dfn>internal vector</dfn>. The <a>query</a> operation returns a <a>media state vector</a> as snapshot, and the <a>update</a> operation requires a <a>media state vector</a> as parameter. Finally, in the distributed scenario, the <a>media state vector</a> is the unit of distribution.
      </p>

      <p><a title="media state vector">Media state vectors</a> implement the following interface</p>

      <dl title="interface MediaStateVector" class="idl">
        <dt>readonly attribute double position</dt>
        <dd>Position on a uni-dimensional axis.</dd>

        <dt>readonly attribute double velocity</dt>
        <dd>Velocity along a uni-dimensional axis.</dd>

        <dt>readonly attribute double acceleration</dt>
        <dd>Acceleration along a uni-dimensional axis.</dd>

        <dt>readonly attribute double timestamp</dt>
        <dd>Timestamp from system clock. The moment in time when <code>position</code>, <code>velocity</code> and <code>acceleration</code> were|are|will be valid.</dd>
      </dl>
    </section>






    <!-- INTERVAL -->



    <section>
      <h2>Interval Object</h2>
      <p>
        An <dfn>interval</dfn> is a representation of a mathematical interval of real numbers. Attributes <code>low</code> and <code>high</code> are endpoints defining the interval. <code>(low &lt;= high)</code> is always true. If <code>(low === high)</code> the interval is a singular point. <code>low</code> and <code>high</code> may be set to <code>Infinity</code> or <code>-Infinity</code> to represent infinite intervals. Attributes <code>lowInclude</code> and <code>highInclude</code> determine whether endpoints <code>low</code> and <code>high</code> are included or excluded from the interval.
      </p>


      <dl title="interface Interval" class="idl">
      <dt>readonly attribute unrestricted double low</dt>
      <dt>readonly attribute unrestricted double high</dt>
      <dt>readonly attribute boolean lowInclude</dt>
      <dt>readonly attribute boolean highInclude</dt>
      <dt>boolean covers (unrestricted double value)</dt>
        <dd>Returns true if interval covers the given value.</dd>
      <dt>boolean isSingular ()</dt>
        <dd>Returns <code>(low === high)</code>.</dd>
      </dl>

    </section>



    <!-- ALGORITHMS -->


    <section>
      <h2>Algorithms</h2>

        
        <section>
        <h3>Create Timing Object</h3>
        <p>
          When the user agent is required to <dfn>create a new timing object</dfn>, it must run the following steps:
        </p>
        <ol>
          <li>Let <em>timing</em> be a newly constructed <code><a>timing object</a></code>.</li>
          <li>Initialize <em>timing</em>'s internal <a>vector</a>. Default is <code>(0.0, 0.0, 0.0, t)</code>, where <code>t</code> is the local timestamp in seconds when the object is created</li> 
          <li>Return <em>timing</em>.</li>
        </ol>
        </section>

        <section>
        <h3>Process Query</h3>
        <p>
          When the user agent is required to <dfn>process query</dfn>, it must run the following steps:
        </p>
        <ol>
          <li>Let fresh timestamp <code>t</code> from system clock represent processing time of query.</li>
          <li>Let <code>(p<sub>i</sub>, v<sub>i</sub>, a<sub>i</sub>, t<sub>i</sub>)</code> represent the current internal <a>vector</a></li>
          <li>Calculate <code> p = p<sub>i</sub> + v<sub>i</sub> (t - t<sub>i</sub>) + 1/2 a<sub>i</sub> (t - t<sub>i</sub>)<sup>2</sup></code></li>
          <li>Calculate <code> v = v<sub>i</sub> + a<sub>i</sub> (t - t<sub>i</sub>)</code></li>
          <li>Calculate <code> a = a<sub>i</sub></code></li>
          <li>Return a new <a>MediaStateVector</a> (<code>p,v,a,t</code>)</li>
        </ol>
        </section>

        <section>
        <h3>Process Update</h3>
        <p>
          When the user agent is required to <dfn>process update</dfn>, it must run the following steps:
        </p>
        <ol>
          <li>Let fresh timestamp <code>t</code> from system clock represent processing time of update.
          <li>Let <code>vector<sub>i</sub> : (p<sub>i</sub>, v<sub>i</sub>, a<sub>i</sub>, t<sub>i</sub>)</code> represent the current internal <a>vector</a></li>
          <li>Let <code>vector<sub>j</sub> : (p<sub>j</sub>, v<sub>j</sub>, a<sub>j</sub>, t)</code> represent the new <a>vector</a></li>
          <li>If <code>vector<sub>j</sub></code> is incomplete, calculate missing values by following the approach described in <a>process query</a>.</li>
          <li>Replace current internal vector with new vector <code>vector<sub>i</sub> = vector<sub>j</sub></code></li>
          <li><a>Set internal timeout</a> if <a>range</a> is specified for the timing object.</li>
          <li>Fire an event named <code>change</code> at the timing object</li>
        </ol>
        </section>


        <section>
          <h3>Set Internal Timeout</h3>
          <p>
            If <a>range</a> is specified for the timing object, e.g. <code>[0,123]</code>, the timing object must schedule a future <a>update</a> operation on itself, to ensure that the <a>range</a> is not violated.
          <p>
          <p>
            When the user agent is required to <dfn>set internal timeout</dfn>, it must run the following steps:
          </p>
          <ol>
            <li> Cancel any pending timeout </li>
            <li> Given current motion, calculate which <a>range</a> endpoint <code>(low|high)</code> will be violated first, if any, and when this will occur.</li>
            <li> Register new timeout for future <a>range</a> violation. Default action is to pause the timing object at the endpoint. <span class="note">This mechanism may be extended to support loopback</span></li> 
          </ol>
        </section>
    </section>



    <section>
    <h3> Distributed Synchronization </h3>

    <p>
      Built-in support for distributed synchronization is a key feature of the timing object. Timing objects on different devices will be synchronized if they individually connect to, and synchronize with, the same online timing resourse. If the implementation of this synchronization is precise and reliable, we can support the abstraction that timing objects are shared among multiple devices and components, across the Internet. Implementation addresses two distinct issues; <dfn>update synchronization</dfn> and <dfn>clock synchronization</dfn>. A brief introduction is given below. Details are available in [[MSV]]. <span class="note">Details of the protocol and synchronization policies will be covered upcomong Timing Protocol Spec</span>.
    </p>

    <section>
      <h3> Update synchronization </h3>
      <p>If an online timing resource is <a title="update">updated</a>, effects must apply equally to all connected timing objects, as quickly as possible.</p>

      <p>
        Update synchronization uses the <a>media state vector</a> as the unit of distribution. Implementation of distributed synchronization implies that local timing objects become local representatives for online timing resources. This has implications for <a title="process update">update processing</a>. Local timing objects will no longer process updates themselves, but simply forward update requests (i.e. the <a>media state vector</a> parameter) across the network to the online timing resource. The algorithm for <a title="process update"> update processing</a> will instead be carried out by the timing service. Effects (i.e. the new <a>media state vector</a>) are multicast by the timing service to all connected timing objects, finally triggering the update event. <a title="process query">Query processing</a> will remain unchanged. Queries are always resolved locally, using the last <a>media state vector</a> received from the server.
      </p>

      <p>
        Note that this strategy does not guarantee that timing objects receive update notification at exactly the same time. It would be possible to mask differences in network latency by introducing additional delay, but as this might hurt user experience, by default we do not do this. <span class="note">Support for delayed update processing might be a future extension</span>. In any case, this choice does not affect precision, see below.
      </p>
    </section>


    <section>
      <h3> Clock synchronization </h3>
      <p> 
        If multiple timing objects (connected to the same online timing resource) are <a title="query">queried</a> at the exact same moment in time, they must ideally provide the same result (i.e. same position, velocity and acceleration). Implementations must approximate this as much as possible.
      </p>
      <p>
        Clock synchronization among timing service and timing objects is required for <a title="media state vector">media state vectors</a> to resolve to the same position, velocity and acceleration. As synchronized system clocks is not a valid assumption in the Web environment, it follows that clock synchronization must be resolved as part of the communication between timing objects and timing service. To do this, timing objects maintain a software clock that is continuously synchronized with the system clock of the timing service. This is possible by means of periodic measurements of RTT and clock skew. Using this server clock, timing objects can tranform <a title="media state vector">media state vectors</a> with respect to their own local system clock. Clock synchronization is also very fast, stable estimates are reached within fractions of a second. Given a strict client-server architecture, this is the optimal approach.
      </p>
      <p>
        Implementation relies on open Web sockets connections to minimize latency between timing objects and the timing service. If implemented correctly in both client and server, this approach provides a basis for sub-framerate media synchronization.
      </p>
    </section>





    </section>
  </body>
</html>
